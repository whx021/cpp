# const

# const说明

const局部变量依然可以修改，使用指针简介修改；const全局变量使用指针简介修改，可以编译通过但是运行错误

通常的理解，const修饰的变量是不可修改的。显然并不是，const关键字在某种程度上来说只是一个面向编译器和程序员的幌子，并不能保证被修饰的内容的不变性。

对于const修饰的局部常量而言，g++编译器（不同编译器机制未必相同）会为其分配内存，由于是静态分配而且是局部常量，因此分配在栈中。
对代码中直接引用到该常量的情况，编译器会将其直接替换成定义时赋的值。这样一来，无论运行期该常量所在内存被如何修改，都不会影响常量的使用。对于取址操作&ar而言，&a整体被当作一个右值，没有被编译器替换成常值，这也是为什么既然编译器还要为const修饰的常量分配内存的原因。
const只在编译期间保证常量被使用时的不变性，无法保证运行期间的行为。程序员直接修改常量会得到一个编译错误，但是使用间接指针修改内存，只要符合语法则不会得到任何错误和警告。因为编译器无法得知你是有意还是无意的修改，但是既然定义成const，那么程序员就不应当修改它，不然直接使用变量定义好了。
c语言中原本没有const关键字，后来为了兼容，引入了const，但是编译器对其的操作与c++中不同。

# const常量与宏定义区别

1、编译器处理方式不同。const变量在编译阶段处理，define宏在预处理阶段展开

2、类型和安全检查不同。

3、存储方式不同。define宏仅仅是展开，没有分配内存；const变量有内存地址

4、const  可以节省空间，避免不必要的内存分配。

5、 提高了效率。 编译器通常不为普通const常量分配存储空间，而是将它们保存在==符号表==中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。

在C++ 程序中只使用const常量而不使用宏常量，即const常量完全取代宏常量。