// 48、内联函数的引出：宏的缺陷
// 内联函数（inline function） 
// 
// 在C中，我们经常将一些短，并且执行频繁的计算写成宏，而不是函数
// 这样做的理由是为了执行效率，宏可以避免函数调用的系统栈上的时间开销，这些都是由预处理完成
//
// C++中预处理宏会出现的问题：
// 1、C中也会出现，宏看起来像函数的调用，但是会隐藏一些难以发现的错误
// 2、C++特有的问题，预处理不能访问类成员，宏不能用作类的成员函数
//
// 总结：内联函数仅仅是给编译器一个建议，编译器不一定会接受这种建议，
//	   如果你函数没有声明为内联函数，编译器也可能将此函数做内联函数，
//	   一个好的编译器，会内联小的、简单的函数

#include <iostream>
using namespace std;

// 宏缺陷1：需要加括号，保证运算的完整
#define	MYADD(x, y) ((x) + (y))

void test_1(void) {
	// 宏在预处理阶段直接替换，产生运算优先级的问题
	int result = MYADD(10, 20) * 20;
	cout << "result = " << result << endl;
}

// 宏缺陷2：即使加了括号，有些情况依然与预期效果不符
#define MYCOMPARE(a, b) (((a) < (b)) ? (a) : (b))

// 内联函数优点：解决了宏的缺陷：因为是普通函数，又带来了宏的优点：调用的系统栈上的时间开销
// 关键字		inline
// 函数的声明和函数的实现要同时拥有inline才算内联

inline int myCompare(int a, int b);
inline int myCompare(int a, int b) {
	return a < b ? a : b;
}

// 类内部的内联函数
// 任何在类内部定义的成员函数自动成为内联函数
// 类的成员函数,都隐藏的加了inline关键字,都是内联函数

// 内联函数与编译器
//
// 以下情况，编译器可能考虑不会将函数进行内联编译
// 1、内联函数中不可含有循环；
// 2、内联函数中不可含有switch语句；
// 3、内联函数中不可能含有静态变量；
// 4、内联函数不可为递归函数；
// 5、内联函数中不可含有错误处理。
// 6、内联函数中不能存在过多if,else条件判断语句
// 7、函数体不能过于庞大
// 8、不能对函数进行取地址操作

void test_2(void) {
	int a = 10;
	int b = 20;

	// int result = MYCOMPARE(++a, b);
	int result = myCompare(++a, b);			// 正常函数结果：11
	cout << "result = " << result << endl;	// 预期效果：11,使用宏定义实际效果：12
}

int main(void) {
	test_2();
	return EXIT_SUCCESS;
}