// 22、对象特性——构造函数和析构函数
// 我们自己不提供构造与析构，编译器会提供
// 编译器提供的构造函数和析构函数是空实现（函数体内为空）
// 我们提供用我们的，我们不提供用编译器的 
// 
// 1、构造函数：对类进行初始化操作
// 	主要作用在于在创建对象时对对象的成员属性赋值
// 	语法：类名() {}
// 	构造函数，没有返回值也不写void
// 	构造函数名与类名相同
//  构造函数可以有参数，可以发生重载
// 	程序在调用对象时，自动调用，无需手动调用，而且仅调用一次
// 
// 2、析构函数：对类进行清理操作
//	主要作用在于对象销毁前系统自动调用，执行一些清理工作，清理成员属性在堆区申请的内存
//	语法：~类名() {}
// 	构造函数，没有返回值也不写void
// 	构造函数名与类名相同，在名称前面加'~'
// 	构造函数不可以有参数，不可以发生重载
// 	程序在销毁对象前，自动调用，无需手动调用，而且仅调用一次

#include <iostream>
using namespace std;

class Person {
public:
	// 1、构造函数：对类进行初始化操作
	//	主要作用在于在创建对象时对对象的成员属性赋值
	// 	语法：类名() {}
	// 	构造函数，没有返回值也不写void
	// 	构造函数名与类名相同
	// 	构造函数可以有参数，可以发生重载
	// 	程序在调用对象时，自动调用，无需手动调用，而且仅调用一次
	Person() {
		cout << "Person构造函数的调用" << endl;
	}

	// 2、析构函数：对类进行清理操作
	//	主要作用在于对象销毁前系统自动调用，执行一些清理工作
	//	语法：~类名() {}
	// 	构造函数，没有返回值也不写void
	// 	构造函数名与类名相同，在名称前面加'~'
	// 	构造函数不可以有参数，不可以发生重载
	// 	程序在销毁对象前，自动调用，无需手动调用，而且仅调用一次
	~Person() {
		cout << "Person22析构函数的调用" << endl;
	}
};

void test_1(void) {
	Person p;	// 在栈上，test_1执行完毕后，释放这个对象
}


int main(void) {
	test_1();
	// Person p;
	
	// system("pause");
	return 0;
}